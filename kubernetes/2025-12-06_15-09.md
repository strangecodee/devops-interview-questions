# kubernetes â€” Sat Dec  6 15:09:54 UTC 2025

**Random Topic of the Minute:** Zero-Downtime Deploys

Okay, let's craft a Kubernetes YAML example focusing on achieving zero-downtime deployments. I'll provide a manifest with explanations and consider common strategies like Rolling Updates.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app-deployment
  labels:
    app: my-app
spec:
  replicas: 3  # Start with 3 replicas
  selector:
    matchLabels:
      app: my-app
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 25%  # Allow up to 25% more pods than desired during update
      maxUnavailable: 25% # Allow up to 25% of pods to be unavailable during the update
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-app-container
        image: your-image:v1  # Replace with your actual image
        ports:
        - containerPort: 8080 #The port your application listens on
        readinessProbe:
          httpGet:
            path: /healthz  # Endpoint for readiness check
            port: 8080
          initialDelaySeconds: 5 #Give the app time to startup
          periodSeconds: 10 #Check every 10 seconds
        livenessProbe:
          httpGet:
            path: /healthz
            port: 8080
          initialDelaySeconds: 15
          periodSeconds: 20
        resources:
          requests:
            cpu: 100m
            memory: 256Mi
          limits:
            cpu: 500m
            memory: 512Mi
---
apiVersion: v1
kind: Service
metadata:
  name: my-app-service
spec:
  selector:
    app: my-app
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  type: LoadBalancer #Or NodePort / ClusterIP depending on your requirements

```

**Explanation:**

1.  **`apiVersion: apps/v1`**:  Specifies the Kubernetes API version and the resource type (Deployment).  `apps/v1` is the recommended version for Deployments.

2.  **`kind: Deployment`**:  Defines a Deployment, which manages a set of identical Pods.  Deployments are designed to ensure a desired number of Pods are running and provide rolling updates.

3.  **`metadata`**:
    *   `name`:  The name of the Deployment (`my-app-deployment`).
    *   `labels`:  Labels attached to the Deployment.  These labels are used by the `selector` to identify the Pods managed by this Deployment.

4.  **`spec`**: Defines the desired state of the Deployment.
    *   `replicas: 3`:  Specifies that we want 3 replicas (instances) of our application running.
    *   `selector` : Allows the deployment to find which pods to manage
    *   `strategy` : Defines how the deployment is updated
        * `type: RollingUpdate`: Instructs Kubernetes to use a rolling update strategy. This means new pods are gradually brought up while old pods are gradually taken down.
        * `rollingUpdate`: Defines the parameters for the rolling update
            * `maxSurge: 25%` : Specifies that, during the update, Kubernetes can create a maximum of 25% more Pods than the desired number of replicas.  So, with 3 replicas, Kubernetes can create one additional Pod (rounding up from 0.75) during the update. This helps to ensure sufficient capacity during the update.
            * `maxUnavailable: 25%`: Specifies that, during the update, a maximum of 25% of the original Pods can be unavailable at any given time.  Again, with 3 replicas, this translates to a maximum of 0 pods (rounding down from 0.75) being unavailable at once.  This ensures that the service remains available to users.

5.  **`template`**: Defines the Pod template.  This is the blueprint for the Pods that the Deployment will create.
    *   `metadata`:  Labels to be applied to the Pods.  Crucially, these labels MUST match the `matchLabels` in the `selector` section of the Deployment.
    *   `spec`:  Defines the Pod's specification.
        *   `containers`:  A list of containers that will run inside the Pod.
            *   `name`:  The name of the container.
            *   `image`:  The Docker image to use for the container.  **Important:** Replace `your-image:v1` with the actual name of your Docker image and tag.
            *   `ports`:  Defines the ports that the container exposes. In this example, it's exposing port 8080.
            *   `readinessProbe`: This probe tells Kubernetes when a pod is ready to receive traffic.  If the probe fails, the pod is removed from the service endpoints.  Crucially, if this probe fails during a deployment, it will prevent Kubernetes from terminating older pods until the newer ones are ready. This is key to zero-downtime deployments.  Using `/healthz` is a common pattern, but adapt to your application's health check endpoint.
                *   `httpGet`:  Performs an HTTP GET request to the specified path and port.
                *   `initialDelaySeconds`: The number of seconds after the container has started before readiness probes are initiated.
                *   `periodSeconds`: How often (in seconds) to perform the probe.
            * `livenessProbe`: This probe tells Kubernetes if a pod is alive. If the probe fails, the pod is restarted.
                *   `httpGet`:  Performs an HTTP GET request to the specified path and port.
                *   `initialDelaySeconds`: The number of seconds after the container has started before liveness probes are initiated.
                *   `periodSeconds`: How often (in seconds) to perform the probe.

            * `resources`: Defines the resource requests and limits for the container.  It's good practice to set these to ensure that your application has the resources it needs and doesn't consume excessive resources.
                * `requests`:  Specifies the minimum amount of resources the container requires.
                * `limits`:  Specifies the maximum amount of resources the container is allowed to use.

6.  **`Service` (apiVersion `v1`, kind `Service`)**:
    *   This defines a Service to expose the Deployment.
    *   `selector`:  Matches the labels of the Pods created by the Deployment (`app: my-app`).
    *   `ports`: Defines how the service exposes the pods.
        *   `port`: The port on the service itself (port 80 here).
        *   `targetPort`: The port on the pods that the service forwards traffic to (port 8080).
    *   `type: LoadBalancer`:  Exposes the service externally using a cloud provider's load balancer. This can be changed to `NodePort` or `ClusterIP` depending on your environment and needs.

**Key Concepts for Zero-Downtime:**

*   **Rolling Updates:** The core of zero-downtime deployments. New Pods are created and gradually replace the old ones.
*   **Readiness Probes:**  Essential.  These probes ensure that new Pods are only added to the service's endpoint list *after* they are fully ready to serve traffic.  Kubernetes will wait for the readiness probe to succeed before removing older pods.
*   **Liveness Probes:** While not directly contributing to zero-downtime, they are important for ensuring the health of the application and restarting unhealthy pods.
*   **Replicas:**  Having multiple replicas is crucial so that there is always at least one instance of your application available during the deployment.
*   **`maxSurge` and `maxUnavailable`:**  Fine-tune these values based on your application's resource requirements and tolerance for unavailability.  For production environments, you typically want a low `maxUnavailable` (e.g., 0 or 25%) and a reasonable `maxSurge` to ensure capacity.
*   **Health Checks:** Your application needs to provide a reliable health check endpoint (e.g., `/healthz`).
*   **Graceful Shutdown:**  Your application should handle shutdown signals gracefully.  When a Pod is being terminated, Kubernetes sends a `SIGTERM` signal.  Your application should stop accepting new connections, finish processing existing requests, and then exit.

**How the Deployment Works:**

1.  **Initial State:** The Deployment starts by creating 3 Pods based on the `your-image:v1` image.
2.  **Update:** When you update the Deployment (e.g., by changing the `image` to `your-image:v2`), Kubernetes starts the rolling update process.
3.  **New Pods:** Kubernetes creates new Pods running `your-image:v2` *before* it removes the old Pods.  The `maxSurge` parameter controls how many new Pods can be created at once.
4.  **Readiness Check:**  Kubernetes waits for the readiness probe to succeed on the new Pods.  Only when the probe passes is the Pod considered ready to serve traffic.
5.  **Traffic Routing:** Once the new Pods are ready, Kubernetes updates the Service to include the new Pods in the endpoint list and removes older pods from the endpoint list.  This ensures that traffic is gradually shifted to the new version of your application. The `maxUnavailable` parameter ensures that a sufficient number of old Pods remain available during this transition.
6.  **Old Pod Removal:**  After the traffic is shifted, Kubernetes removes the old Pods running `your-image:v1`.

**Important Considerations:**

*   **Database Migrations:**  Zero-downtime deployments become more complex when you need to perform database schema migrations. You need to ensure that your new application version is compatible with both the old and new database schema during the transition. Consider using techniques like blue/green deployments or canary deployments for database migrations.
*   **Session Management:**  If your application relies on in-memory sessions, you'll need to implement a mechanism for session replication or persistence to avoid losing user sessions during the update.
*   **External Dependencies:** Ensure that any external dependencies your application relies on are also highly available and can handle traffic during the deployment.
*   **Monitoring:**  Monitor your deployments closely to ensure that they are proceeding as expected and that there are no errors or performance issues.

This comprehensive example provides a foundation for achieving zero-downtime deployments in Kubernetes.  Remember to tailor the configuration to your specific application requirements and environment.  Always test your deployment strategy in a non-production environment before deploying to production.
