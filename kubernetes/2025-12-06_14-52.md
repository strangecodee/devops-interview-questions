# kubernetes â€” Sat Dec  6 14:53:01 UTC 2025

**Random Topic of the Minute:** Monitoring

Okay, let's generate a Kubernetes YAML example for monitoring, along with a detailed explanation. We'll focus on deploying Prometheus using the Prometheus Operator. We'll also include ServiceMonitors to configure Prometheus to monitor our applications.

**Seed:** 1765032760

**Generated YAML (Multiple Files):**

We'll divide this into several files for better organization and readability.

**1.  prometheus-operator.yaml:** (This deploys the core Prometheus Operator)

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: prometheus-operator
  namespace: monitoring
  labels:
    app: prometheus-operator
spec:
  replicas: 1
  selector:
    matchLabels:
      app: prometheus-operator
  template:
    metadata:
      labels:
        app: prometheus-operator
    spec:
      serviceAccountName: prometheus-operator
      containers:
        - name: prometheus-operator
          image: quay.io/prometheus-operator/prometheus-operator:v0.68.0 # Use a stable version
          args:
            - --prometheus-instance-namespace=monitoring
            - --kubelet-service=kube-system/kubelet
            - --log-level=info
          ports:
            - containerPort: 8080
              name: http
              protocol: TCP
          resources:
            requests:
              cpu: 100m
              memory: 200Mi
            limits:
              cpu: 500m
              memory: 500Mi
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: prometheus-operator
  namespace: monitoring
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: prometheus-operator
rules:
  - apiGroups:
      - monitoring.coreos.com
    resources:
      - prometheuses
      - prometheuses/status
      - prometheusrules
      - servicemonitors
      - podmonitors
    verbs:
      - '*'
  - apiGroups:
      - apps
    resources:
      - deployments
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - ""
    resources:
      - nodes
      - services
      - endpoints
      - pods
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - ""
    resources:
      - configmaps
      - secrets
    verbs:
      - get
      - create
      - update
  - apiGroups:
      - coordination.k8s.io
    resources:
      - leases
    verbs:
      - get
      - create
      - update
  - apiGroups:
      - admissionregistration.k8s.io
    resources:
      - mutatingwebhookconfigurations
      - validatingwebhookconfigurations
    verbs:
      - get
      - create
      - update
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: prometheus-operator
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: prometheus-operator
subjects:
  - kind: ServiceAccount
    name: prometheus-operator
    namespace: monitoring
```

**2. prometheus.yaml:** (This defines the Prometheus instance managed by the Operator)

```yaml
apiVersion: monitoring.coreos.com/v1
kind: Prometheus
metadata:
  name: prometheus
  namespace: monitoring
spec:
  serviceAccountName: prometheus
  serviceMonitorSelector:
    matchLabels:
      release: my-app # Matches the label on the ServiceMonitor
  podMonitorSelector: {} # Selects all PodMonitors in the namespace.  Change to select specific PodMonitors.
  replicas: 1
  version: v2.49.1 # Use a stable version
  resources:
    requests:
      memory: 2Gi
    limits:
      memory: 4Gi
  securityContext:
    fsGroup: 65534 # Required for some security setups
  # Enable persistent storage
  storage:
    volumeClaimTemplate:
      spec:
        accessModes:      [ "ReadWriteOnce" ]
        resources:
          requests:
            storage: 10Gi

---

apiVersion: v1
kind: ServiceAccount
metadata:
  name: prometheus
  namespace: monitoring
```

**3. servicemonitor.yaml:** (This defines *how* Prometheus discovers and scrapes metrics from a specific service.  Here, it's monitoring an example application called `my-app-service` in the `default` namespace.)

```yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: my-app-service-monitor
  namespace: monitoring
  labels:
    release: my-app # Used by the Prometheus ServiceMonitorSelector
spec:
  selector:
    matchLabels:
      app: my-app  # Match the labels of the service you want to monitor
  namespaceSelector:
    matchNames:
      - default      # The namespace where your target service resides
  endpoints:
    - port: web        # The name of the port on the Service that exposes metrics
      interval: 30s     # How often to scrape
      path: /metrics    # The path where metrics are exposed (e.g., /metrics)
      scrapeTimeout: 10s
      relabelings:
        - sourceLabels: [__meta_kubernetes_pod_node_name]
          targetLabel: node
```

**4. grafana.yaml** (Optional: Deploys a Grafana instance to visualize the metrics)

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: grafana
  namespace: monitoring
spec:
  selector:
    matchLabels:
      app: grafana
  template:
    metadata:
      labels:
        app: grafana
    spec:
      containers:
        - name: grafana
          image: grafana/grafana:latest # Use a stable version
          ports:
            - containerPort: 3000
              name: http
              protocol: TCP
          volumeMounts:
            - name: grafana-storage
              mountPath: /var/lib/grafana
          resources:
            requests:
              cpu: 100m
              memory: 200Mi
            limits:
              cpu: 500m
              memory: 500Mi
      volumes:
        - name: grafana-storage
          emptyDir: {} # Change to PersistentVolumeClaim for persistent storage
---
apiVersion: v1
kind: Service
metadata:
  name: grafana
  namespace: monitoring
spec:
  selector:
    app: grafana
  ports:
    - port: 3000
      targetPort: 3000
      protocol: TCP
  type: NodePort  # Change to LoadBalancer for external access (if supported)
```

**Explanation:**

1.  **`prometheus-operator.yaml`:**

    *   **`Deployment` `prometheus-operator`:** This deploys the Prometheus Operator itself. The Operator's job is to manage Prometheus instances and Alertmanager based on custom resources.
    *   `image`: Specifies the Docker image for the Prometheus Operator. **Important:** Choose a stable, versioned image.  Avoid `latest`.
    *   `args`: Configure the Operator:
        *   `--prometheus-instance-namespace`: Tells the operator which namespace to look for Prometheus resources in.
        *   `--kubelet-service`:  Configures access to kubelet metrics.
    *   `ServiceAccount`, `ClusterRole`, `ClusterRoleBinding`:  These define the permissions the Prometheus Operator needs to manage resources across the cluster.  It needs to be able to create, read, update, and delete Prometheus instances, ServiceMonitors, etc.  These are important for security.

2.  **`prometheus.yaml`:**

    *   **`Prometheus` (Custom Resource Definition from the Operator):**  This *defines* the Prometheus instance you want to deploy.  The Operator will create the actual pods, services, etc., based on this definition.
    *   `serviceAccountName`:  Specifies the Service Account that the Prometheus instance will use.
    *   `serviceMonitorSelector`:  A `matchLabels` selector that specifies which ServiceMonitors this Prometheus instance should use.  In this case, it selects ServiceMonitors with the label `release: my-app`.
    *   `podMonitorSelector`: Similar to `serviceMonitorSelector`, but selects `PodMonitor` custom resources. The `PodMonitor` resource is used to configure how Prometheus discovers and scrapes metrics directly from pods, without relying on a Kubernetes Service.  An empty selector selects all PodMonitors in the namespace.
    *   `replicas`: The number of Prometheus replicas to run for high availability.
    *   `version`:  The Prometheus version to use. **Important:** Choose a stable, versioned image. Avoid `latest`.
    *   `resources`:  CPU and memory requests and limits for the Prometheus pods.  Adjust these based on the size and complexity of your environment.
    *   `storage`: Configures persistent storage for Prometheus so that metrics are retained across pod restarts. The `volumeClaimTemplate` defines the characteristics of the PersistentVolumeClaim that will be created.
    * `securityContext`:  Configures the security context for the prometheus pods.  fsGroup is needed for some persistent volume setups.

3.  **`servicemonitor.yaml`:**

    *   **`ServiceMonitor` (Custom Resource Definition from the Operator):** This tells Prometheus *how* to monitor a specific Kubernetes service.
    *   `selector`: `matchLabels` that identify the Service to be monitored.  It should match the labels applied to your target service.  In this example, it looks for a Service with the label `app: my-app`.
    *   `namespaceSelector`:  `matchNames` that specifies the namespaces where the Service you want to monitor resides. Here, it's monitoring the `default` namespace.
    *   `endpoints`: Describes how to scrape metrics from the service's endpoints:
        *   `port`: The name of the port on the Service where metrics are exposed.  This *must* match the `name` of the port definition in your Service YAML.
        *   `interval`: How often to scrape the metrics endpoint.
        *   `path`: The path on the endpoint where metrics are exposed (e.g., `/metrics`).
        *   `scrapeTimeout`: The maximum time to wait for a scrape to complete.
        *   `relabelings`: Allows you to modify labels before they are stored in Prometheus. This can be useful for adding, modifying, or removing labels. In this example, the node the pod runs on is added to the metrics as a label.

4.  **`grafana.yaml` (Optional):**

    *   `Deployment grafana`:  Deploys Grafana.
    *   `Service grafana`:  Exposes Grafana.  Note the `type: NodePort`. This means you can access Grafana using the node's IP address and the assigned port (e.g., `http://<node-ip>:<node-port>`).  For production, you'd likely want to use a `LoadBalancer` or an Ingress controller.  The service would connect to Prometheus.
    *   `volumeMounts`/`volumes`: For persistence, it is best to set this up with a PersistentVolumeClaim so Grafana settings are retained on restarts.

**How to Deploy:**

1.  **Create the `monitoring` namespace:** `kubectl create namespace monitoring`
2.  **Apply the YAML files:**  Use `kubectl apply -f prometheus-operator.yaml`, `kubectl apply -f prometheus.yaml`, `kubectl apply -f servicemonitor.yaml`, and `kubectl apply -f grafana.yaml`.
3.  **Verify:** Check that the Prometheus Operator, Prometheus instance, and Grafana pods are running correctly in the `monitoring` namespace using `kubectl get pods -n monitoring`.
4.  **Access Grafana:**  Find the NodePort for the Grafana service using `kubectl get svc grafana -n monitoring`. Then access it in your browser: `http://<node-ip>:<node-port>`.

**Important Considerations:**

*   **Versions:** Use stable, versioned images for all components (Prometheus Operator, Prometheus, Grafana).  Avoid `latest` to prevent unexpected breaking changes.
*   **Security:**  Carefully review the RBAC permissions granted to the Prometheus Operator.  Grant only the necessary permissions.  Consider using PSPs (Pod Security Policies) or other security mechanisms to further restrict the pods.
*   **Storage:**  Use PersistentVolumes and PersistentVolumeClaims for both Prometheus and Grafana to ensure that data is retained across pod restarts.
*   **Configuration:**  Customize the `serviceMonitor.yaml` to match your specific application's labels, namespaces, and metrics endpoint.
*   **Alerting:**  Prometheus is designed to be used with Alertmanager for alerting.  You'll need to configure Alertmanager separately.  The Prometheus Operator can also manage Alertmanager instances.
*   **Resource Limits:**  Adjust the `resources` (CPU and memory) requests and limits for Prometheus and Grafana based on the size of your environment. Over-provisioning can waste resources, while under-provisioning can lead to performance issues.
*   **High Availability:**  For production environments, consider running multiple Prometheus replicas for high availability.

This example provides a good starting point for monitoring your Kubernetes applications using Prometheus and Grafana. Remember to adapt the configurations to your specific needs and environment.  You'll also want to learn about PromQL (Prometheus Query Language) to create effective dashboards and alerts.
