# kubernetes — Sat Dec  6 14:44:07 UTC 2025

**Random Topic of the Minute:** GitOps

```yaml
---
# Source: my-gitops-app/templates/argocd-application.yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: my-gitops-app
  namespace: argocd
  finalizers:
    - resources.argoproj.io/finalizer
spec:
  destination:
    namespace: my-app-namespace
    server: https://kubernetes.default.svc # Internal Kubernetes API server
  project: default # ArgoCD project to which the application belongs
  source:
    repoURL: https://github.com/your-org/your-gitops-repo.git # Replace with your Git repository URL
    targetRevision: HEAD # Track the HEAD of the specified branch
    path: manifests/my-app # Path within the Git repository where Kubernetes manifests are stored
    directory:
      recurse: true # Enable recursive search for manifests within the path
  syncPolicy:
    automated: # Automated sync settings
      prune: true # Delete resources that are no longer defined in the Git repository
      selfHeal: true # Revert changes made outside of Git
    syncOptions:
      - CreateNamespace=true # Create the namespace if it doesn't exist

---
# Source: my-gitops-app/templates/namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: my-app-namespace
```

**Explanation:**

This example demonstrates a basic GitOps setup using Argo CD for deploying a Kubernetes application.  It includes two YAML resources: an Argo CD `Application` and a Kubernetes `Namespace`.

**1. Argo CD `Application` Resource (`argocd-application.yaml`):**

*   **`apiVersion: argoproj.io/v1alpha1` and `kind: Application`:**  Specifies the API version and kind of resource, which defines an Argo CD application.
*   **`metadata:`:** Contains metadata about the application:
    *   `name: my-gitops-app`:  The name of the Argo CD application.  This should be unique within the Argo CD namespace.
    *   `namespace: argocd`: The namespace where Argo CD is deployed.  Applications must reside within the Argo CD namespace.
    *   `finalizers: - resources.argoproj.io/finalizer`:  Ensures that Argo CD properly cleans up resources when the application is deleted.
*   **`spec:`:**  Defines the desired state of the application:
    *   **`destination:`:** Specifies where the application should be deployed.
        *   `namespace: my-app-namespace`: The Kubernetes namespace to deploy the application to.  This corresponds to the `Namespace` resource defined below.
        *   `server: https://kubernetes.default.svc`: The Kubernetes API server address. This defaults to the internal Kubernetes API server within the cluster.  This tells Argo CD which Kubernetes cluster to deploy to.
    *   **`project: default`:** The Argo CD project the application belongs to.  Projects are used for access control and organization within Argo CD.  The `default` project is automatically created.
    *   **`source:`:** Specifies the source of truth for the application's configuration.  This is the core of GitOps.
        *   `repoURL: https://github.com/your-org/your-gitops-repo.git`:  The URL of the Git repository containing the Kubernetes manifests.  **Replace this with your actual repository URL.**
        *   `targetRevision: HEAD`:  The Git revision (branch, tag, or commit) to track.  `HEAD` refers to the latest commit on the default branch (usually `main` or `master`).  You can specify a specific branch name (e.g., `main`) or a tag name.
        *   `path: manifests/my-app`:  The path within the Git repository where the Kubernetes manifests are located.  Argo CD will look for YAML files in this directory.
        *   `directory:`
            *   `recurse: true`: This tells Argo CD to recursively search the specified `path` for Kubernetes manifests.
    *   **`syncPolicy:`:** Defines how Argo CD synchronizes the application's state with the desired state in Git.
        *   **`automated:`:** Enables automated synchronization.
            *   `prune: true`: When set to `true`, Argo CD will automatically delete resources in the Kubernetes cluster that are no longer defined in the Git repository.  This ensures that the cluster state matches the desired state in Git.
            *   `selfHeal: true`: When set to `true`, Argo CD will automatically revert any changes made to the application's resources that were not made through Git.  This prevents manual modifications from drifting the cluster state away from the desired state.
        *   **`syncOptions:`:** Allows you to configure additional synchronization options.
            *   `CreateNamespace=true`:  Instructs Argo CD to create the destination namespace if it doesn't already exist. This is very useful for bootstrapping the process.

**2. Kubernetes `Namespace` Resource (`namespace.yaml`):**

*   **`apiVersion: v1` and `kind: Namespace`:**  Specifies that this is a Kubernetes Namespace resource.
*   **`metadata:`:**
    *   `name: my-app-namespace`: The name of the namespace.  This corresponds to the `destination.namespace` in the Argo CD `Application` resource.  All the Kubernetes resources defined in the `manifests/my-app` directory in your Git repository will be deployed to this namespace.

**How it works in GitOps:**

1.  You commit the YAML files to your Git repository (e.g., GitHub, GitLab, Bitbucket).
2.  Argo CD is configured to monitor the specified Git repository and path.
3.  When Argo CD detects changes in the Git repository (e.g., a new commit), it automatically synchronizes the application's state in the Kubernetes cluster to match the desired state defined in the Git repository.
4.  If `automated.prune` is enabled, Argo CD will delete any resources in the cluster that are no longer defined in the Git repository.
5.  If `automated.selfHeal` is enabled, Argo CD will revert any manual changes made to the application's resources in the cluster.

**To use this example:**

1.  **Install Argo CD:** Follow the Argo CD installation instructions to deploy it to your Kubernetes cluster.
2.  **Create a Git Repository:** Create a Git repository and structure it as follows:
    ```
    your-gitops-repo/
    ├── manifests/
    │   └── my-app/
    │       ├── deployment.yaml
    │       ├── service.yaml
    │       └── ... (other Kubernetes manifests)
    └── argocd-application.yaml
    └── namespace.yaml
    ```
    *   Place your Kubernetes manifests (e.g., Deployments, Services, ConfigMaps, etc.) in the `manifests/my-app` directory.
    *   Create `argocd-application.yaml` and `namespace.yaml` files based on the example above.
3.  **Update `argocd-application.yaml`:**  Replace `https://github.com/your-org/your-gitops-repo.git` with your actual Git repository URL.
4.  **Apply the `argocd-application.yaml`:** Use `kubectl apply -f argocd-application.yaml -n argocd` to create the Argo CD application.
5.  **Monitor the Application in Argo CD:**  Access the Argo CD UI (usually through a LoadBalancer or NodePort service) and monitor the progress of the application deployment.

This example provides a foundation for implementing GitOps with Argo CD. You can extend it to include more complex configurations, such as using Helm charts, Kustomize, or other templating tools. Remember to adapt the paths and configurations to match your specific application and Git repository structure.
