# docker â€” Sat Jan 10 15:05:15 IST 2026
**Topic:** Chaos Engineering
**Style:** Performance-optimized
**Depth:** Medium detail
**UniqueKeyword:** forge

 # Use Multi-stage Builds in Dockerfiles
Use multi-stage builds to minimize image size and improve security by separating build and runtime environments.

# Explanation
Multi-stage builds allow you to create multiple build stages in a single Dockerfile, enabling you to perform multiple build steps and discard unnecessary artifacts from the final image. This leads to smaller image sizes and better security by keeping sensitive build tools and libraries out of your runtime environment.

# Why It Matters
- Smaller image sizes lead to faster download and deployment times, reducing the overall time to market for your applications.
- Separating build and runtime environments minimizes the attack surface and helps ensure that vulnerabilities in build tools and libraries don't compromise the production environment.

# Example
```Dockerfile
# Use a base image for building the application
FROM node:14 as build

# Install dependencies and build the application
WORKDIR /app
COPY package.json yarn.lock ./
RUN yarn install
COPY . .
RUN yarn build

# Create a new stage for the runtime environment
FROM nginx:latest
COPY --from=build /app/build /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```
In this example, the Dockerfile uses two stages - the build stage (`node:14`) and the runtime stage (`nginx:latest`). The build stage installs dependencies and builds the application, while the runtime stage runs the Nginx web server and serves the built application. The final image will only include the Nginx runtime environment, making it more lightweight and secure.
