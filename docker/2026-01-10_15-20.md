# docker â€” Sat Jan 10 15:20:18 IST 2026
**Topic:** ArgoCD
**Style:** SRE-focused
**Depth:** Low detail
**UniqueKeyword:** matrix

 # Best Practice: Use Multi-stage Builds in Dockerfiles for Reducing Image Size and Improving Security
<Building Docker images in multiple stages helps to reduce image size and improve security by separating the build process from the final runtime environment>

# Explanation
Docker multi-stage builds allow you to create multiple build stages in a single Dockerfile. In each stage, you can install and configure dependencies, build the application, and prepare the image for production. The final image is constructed from the last stage only, discarding all the intermediate containers and their contents.

By separating the build environment from the runtime environment, multi-stage builds help to reduce the image size and minimize the attack surface. Additionally, they provide a more streamlined and efficient build process, as you don't need to install unnecessary packages for the runtime environment during the build.

# Why It Matters
- **Reduces Image Size**: Multi-stage builds help to reduce the image size by keeping intermediate containers and their contents out of the final image. This is essential for deploying applications quickly and efficiently, especially when dealing with large applications or limited network bandwidth.
- **Improves Security**: By separating the build environment and the runtime environment, multi-stage builds help to minimize the attack surface by removing unnecessary packages and dependencies. This makes your images less vulnerable to potential security threats.
- **Streamlines the Build Process**: Multi-stage builds help to make the build process more efficient by allowing you to separate the installation of dependencies and the building of the application into separate stages. This results in a cleaner and more organized Dockerfile.

# Example
```Dockerfile
# First stage: Install dependencies
FROM node:14 as build
WORKDIR /app
COPY package.json yarn.lock .
RUN yarn install

# Second stage: Build the application
FROM node:14 as runtime
WORKDIR /app
COPY --from=build /app .
RUN yarn build

# Final stage: Set entry point
FROM node:14
WORKDIR /app
COPY --from=runtime /app .
ENTRYPOINT ["npm", "start"]
```
In this example, we use two stages (build and runtime) to install dependencies (first stage) and build the application (second stage), while the final image (third stage) is based on a minimal Node.js runtime image and sets the entry point to start the application.
